Tcp协议在建立连接的时候需要建立三次握手的过程，
    第一次，是由客户端向服务器发起的，这是一个用来去发起一个连接建立的请求，那么这个报文中的SYN会被标记为1，所以通常把他叫做SYN包，
    第二次握手是由服务器向客户端发送，是来确认一个服务器的请求连接的，这个报文中我们的ACK位还有SYN位都会被标记为1；所以通常也把他叫做SYN ACK报文；
    第三次请求同样是客户端向服务器段发送请求，这是对服务器的上一个报文的确认报文，这个报文的ACK报文标记为1，所以我们把他叫做ACK包

为什么说TCP是可靠的传输协议
    Tcp是基于点对点建立的连接，
    
    
什么是面向对象，面向对象的主要特征是什么！
  面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态

什么是OOP
    oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成

OOP具有三大特点
    1、封装性：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。

    2、继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。

    3、多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。

    1、易维护

    采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。

    2、质量高

    在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。

    3、效率高

    在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。

    4、易扩展

    由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。

smarty 是什么，有什么作用
    回答一:smarty是用php写出来的模板引擎,也是目前业界最著名的php模板引擎之一

    它分离了逻辑代码和外在的显示,提供了一种易于管理和使用的方法,用来将混杂的php逻辑代码与html代码进行分离

    回答二:smarty是php中最著名的引擎框架之一,我们公司使用的是TP框架,已经封装好了smarty模板,所以没有单独使用过

    回答三: smarty是个模板引擎，最显著的地方就是有可以把模板缓存起来。一般模板来说，都是做一个静态页面，然后在里面把一些动态的部分用一切分隔符切开，然后在PHP里打开这个模板文件，把分隔符里面的值替换掉，然后输出来，你可以看下PHPLib里面的template部分。

    而smarty设定了缓存参数以后，第一次运行时候会把模板打开，在php替换里面值的时候把读取的html和php部分重新生成一个临时的php文件，这样就省去了每次打开都重新读取html了。如果修改了模板，只要重新刷下就行了。
    
    
    
    
    
13.请介绍一下laravel框架?

    答: laravel框架的设计思想比较先进,非常适合应用各种开发模式,作为一个框架,它为你准备好了一切,composer是php的未来,没有composer,php肯定要走向没落

    laravel框架最大的特点和优秀之处就是集合了php比较新的特点,以及各种各样的设计模式,Ioc模式,依赖注入等
    
laravel 有哪些特点：
    artisan 命令行工具，很多手动的开发都可以自动化
    社区活跃，
    而且框架还引入了门面，依赖注入 容器，以及各种各样的设计模式
    
数据库的优化
  从结构层: web服务器采用负载均衡服务器，mysql才哟个主从复制，读写分离
  从存储层：采用合适的存储引擎，采用三范式
  从设计层：采用分区 分表，索引 表的字段设计，适当的采用逆范式（反范式），开始mysql 缓存
  sql语句层：在查询结果一样的情况下，采用效率高，速度快 节省资源的sql执行，减少io资源
  
  
  
  工作的时候经常会出现临时 加急 需求，打乱我的计划，搞得这个时候这个任务还没完成，又得去做娶她的任务，最后一天下来，大大小小的东西是很多，但是没有完成的非常好，  （解决方案： 把这些都添加优先级，遇到临时需求按照优先级和已有的任务进行排版，这样保证在规定时间有效率的完成优先级高的任务）
  项目需求远程沟通的时候，遇到问题与合作方很难沟通清楚，从而在 很多方便 达不到支持 （服务器的申请，账号权限的申请） 
 
 技术问题，领导不太懂这个语言的技术，公司没有专门的php 后台开发，
 
应用型接口的开发，cp 需要什么数据，我们就提供相应的数据，配合相应的接口文档


Memcache和Redis 的区别：
  数据结构方面：memcache 只支持
  

索引的优缺点：
    优点：
        a）可以保证数据库表中每一行的数据的唯一性

        b）可以大大加快数据的索引速度

        c）加速表与表之间的连接，物别是在实现数据的参考完事性方面特别有意义

        d）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间

        f）通过使用索引，可以在时间查询的过程中，使用优化隐藏器，提高系统的性能
    
    缺点：
        a)  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

        b)  索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大

        c)  以表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度

        d)  建立索引的原则

        e)  在经常需要搜索的列上，可以加快搜索的速度

        f)  在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构

        g)  在经常用在连接的列上，这些列主要是一外键，可以加快连接的速度

        h)  在经经常需要根据范围进行搜索的列上创建索引，国为索引已经排序，其指定的范围是连续的

        i)  在经常需要排序的列上，国为索引已经排序，这样井底可以利用索引的排序，加快排序井底时间

        j)  在经常使用在where子句中的列上，加快条件的判断速度
        
        
        
一.什么是 CGI？什么是 FastCGI？php-fpm，FastCGI，Nginx 之间是什么关系？
    CGI，通用网关接口，用于WEB服务器和应用程序间的交互，定义输入输出规范，用户的请求通过WEB服务器转发给FastCGI进程，FastCGI进程再调用应用程序进行处理，如php解析器，应用程序的处理结果如html返回给FastCGI，FastCGI返回给Nginx 进行输出。假设这里WEB服务器是Nginx，应用程序是 PHP，而 php-fpm 是管理 FastCGI 的，这也就是 php-fpm，FastCGI，和 Nginx 之间的关系。
  FastCGI 用来提高 cgi 程序性能，启动一个master，再启动多个 worker，不需要每次解析 php.ini. 而 php-fpm 实现了 FastCGI 协议，是 FastCGI 的进程管理器，支持平滑重启，可以启动的时候预先生成多个进程。

二.memcache 和 Redis 的区别
  数据结构：memcache仅支持简单的key-value形式，Redis支持的数据更多（string字符串，set集合，list列表，hash散列，zset有序集合）；

  多线程：memcache支持多线程，Redis支持单线程

  持久化：Redis支持持久化，memcache不支持持久化

  分布式：Redis做主从结构，memcache服务器需要通过hash一致化来支撑主从结构

  实际运用中可以redis，memcache结合，memcache可作为session存储的方式，session都是KV类型键值对。

 

    1. Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别。

    2. Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcache只是简单的K/V缓存。

    3. 他们的扩展都需要做集群；实现方式：master-slave、Hash。

    4. 在100k以上的数据中，Memcache性能要高于Redis。

    5. 如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。

    6. 如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcache都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。

    7. Redis和Memcache在写入性能上面差别不大，读取性能上面尤其是批量读取性能上面Memcache更强

    8.Redis 提供了多种不同级别的持久化方式：

    RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

    AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。

    Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。

    你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

 

三.什么是 Redis 穿透和雪崩
**缓存穿透**:就是访问redis中一个不存在的key的时候,会直接穿过缓存,去数据库中进行查询.

如果是黑客,进行恶意攻击的时候,每次都请求超过2000个/秒的时候,这个时候mysql基本上就挂了.

 

解决办法是:每次从数据库中查询到一个不存在的key的时候,就写一个空值到缓存库中,有恶意攻击的时候,直接从缓存中取到这个空值.

 

**缓存雪崩**:就是每秒有5000个请求过来时候,redis缓存库崩了,然后这些请求瞬间落在了mysql数据库上,直接导致数据库死机.

解决方案就是:

　　事前:提高缓存库的高可用, 使用主从结构加哨兵 cluster集群,

事中:使用ehcache+hystrix限流组件(当请求量非常巨大的时候,就调用自己开发好的一个降级饿组件,返回一些默认值,如友情提示,或者空白值)

事后:做持久化,尽快恢复缓存集群,一旦恢复,自动从磁盘上读取数据,恢复内存中的数据.

 

四.redis 消息队列先进先出需要注意什么？
    通常使用一个list来实现队列操作，这样有一个小限制，所以的任务统一都是先进先出，如果想优先处理某个任务就不太好处理了，这就需要让队列有优先级的概念，我们就可以优先处理高级别的任务，实现方式有以下几种方式：



    1）单一列表实现：队列正常的操作是 左进右出（lpush,rpop）为了先处理高优先级任务，在遇到高级别任务时，可以直接插队，直接放入队列头部（rpush），这样，从队列头部（右侧）获取任务时，取到的就是高优先级的任务（rpop）

    2）使用两个队列，一个普通队列，一个高级队列，针对任务的级别放入不同的队列，获取任务时也很简单，redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的 key 顺序查看，并在找到的第一个非空 list 的尾部弹出一个元素，redis> BRPOP list1 list2 0



    `list1 做为高优先级任务队列`



    `list2 做为普通任务队列`



    `这样就实现了先处理高优先级任务，当没有高优先级任务时，就去获取普通任务`



    `方式1最简单，但实际应用比较局限，方式3可以实现复杂优先级，但实现比较复杂，不利于维护`



    `方式2是推荐用法，实际应用最为合适`

 

五.Redis 如何防止高并发？
    其实redis是不会存在并发问题的，因为他是单进程的，再多的命令都是一个接一个地执行的。我们使用的时候，可能会出现并发问题，比如获得和设定这一对。Redis的为什么 有高并发问题？Redis的的出身决定



    Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对redis进行并发访问时会出现问题。发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。

    同时，单线程的天性决定，高并发对同一个键的操作会排队处理，如果并发量很大，可能造成后来的请求超时。
    在远程访问redis的时候，因为网络等原因造成高并发访问延迟返回的问题。

    解决办法
    在客户端将连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。

服务器角度，利用setnx变向实现锁机制。

六.说说对 SQL 语句优化有哪些方法？
（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。

 

（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。

 

（3） 避免在索引列上使用计算

 

（4）避免在索引列上使用IS NULL和IS NOT NULL

 

（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。　　

 

（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

 

（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
